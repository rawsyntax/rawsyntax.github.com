<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Raw Syntax]]></title>
  <link href="http://rawsyntax.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rawsyntax.com/"/>
  <updated>2011-11-29T00:11:25-05:00</updated>
  <id>http://rawsyntax.com/</id>
  <author>
    <name><![CDATA[Eric Himmelreich]]></name>
    <email><![CDATA[eric@rawsyntax.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Solving the General Case]]></title>
    <link href="http://rawsyntax.com/blog/solving-the-general-case/"/>
    <updated>2011-11-28T16:05:00-05:00</updated>
    <id>http://rawsyntax.com/blog/solving-the-general-case</id>
    <content type="html"><![CDATA[<p><a href="http://xkcd.com/974">
<img src="http://rawsyntax.com/images/the_general_problem.png" class ="center"/>
</a></p>

<p>This XKCD comic struck a chord with me.  I feel that it presents a
false dichotomy.  Either miss deadlines to design it right or go wild
west cowboy coding and meet deadlines.  I think there's a middle ground between
those options.  Design it correctly, but deliver less functionality,
and add the rest of the functionality at a later date.  While that's a
simple solution, this comic touches on other related issues.</p>

<h3>Analysis Paralysis</h3>

<p><img src="http://rawsyntax.com/images/analysis-paralysis.jpg" class ="center"/></p>

<p>This affliction is pretty common largely as a result of all the
choices we have nowadays when designing software.  Which language?
Which Framework? How about a
<a href="/blog/the-problem-with-micro-frameworks/">Micro-Framework</a>?  Which
<a href="/blog/categories/learn-emacs/">Text Editor</a>?  Nevermind questions
about how to actually solve the problem at hand.  If a simple flexible
design is not readily coming to mind, I find it helpful to write some
code that implements the very basics of the functionality needed, and
then re-evaluate to figure out a design.  Its a more iterative
approach.  Write a little code. Refactor.  Hopefully a good design
will emerge.  If not try something else.</p>

<h3>Deadline is not a Bad Word</h3>

<p>Growing up my dad would always tell me: "There is no time", but I
didn't understand what he meant until I got a job at 15 years old.
Deadlines are part of life, and furthermore they are not bad.  A
deadline is just a constraint.  Without deadlines we developers could
work on software design forever and never actually get to
implementation!  Deadlines can actually help cure analysis paralysis
by reducing the number of options available to us.  Rewriting the
whole project in python suddenly isn't an option.  Deadlines force
value judgements to be made.</p>

<h3>Why the General Case Takes so Long</h3>

<p>As you begin implementing your perfect design you may find holes.
This is one of the reasons for the shift from waterfall development to
agile (or even just shorter iterative processes).  Once your design is
implemented to 90% you are constrained with all these implementation
details.</p>

<p>To paraphrase Albert Einstein:
<blockquote><p>"At design-time, design and implementation are the same.  At implementation-time, they are not."</p></blockquote></p>

<p>The following quote is about ruby implementation, but it can be applied to any hard general case problem.</p>

<p><blockquote><p>Listen, people: Ruby is hard to implement. Oh, it may look easy at a glance, and you can probably get 70, 80, or even 90% of the way pretty quickly. But there's some crazy stuff in that last 10% or 5% that totally blindsides you if you're not looking for it. An early Ruby implementation has not run that last mile of Ruby implementation, and it takes almost as much work to get there as it does to run the first 90%.</p><footer><strong>Charles Nutter</strong><cite><a href='http://blog.headius.com/2009/03/on-benchmarking.html'>blog.headius.com/2009/03/&hellip;</a></cite></footer></blockquote></p>

<p>When he talks about getting blindsided by that last 10%, that is
potentially a missed deadline.</p>

<h3>Solving the Problem of Solving the General Case</h3>

<p>  Ask yourself if you can live with a 90% solution.  Do you really need to solve the general case?  If 90% is not enough, break the general
case down into many smaller pieces of functionality and many smaller
deadlines.  You may still run into missed deadlines and problems, but
they will have smaller and more predictable impact.  This doesn't
really solve the overall problem of software that takes too long to
develop, but it makes the problems easier to manage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interviewing for Programmers]]></title>
    <link href="http://rawsyntax.com/blog/interviewing-for-programmers/"/>
    <updated>2011-06-02T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/interviewing-for-programmers</id>
    <content type="html"><![CDATA[<p>Interviewing is a funny thing. In order to get hired for a programming job it's most important to interview well. Getting hired usually doesn't have much to do with programming skills. This is typically a pain point for programmers. Many of us feel that the hiring process should be changed. Personally, I'm ok with the hiring process as it is. It could be improved, but I'm going to tell you how to get a job anyway.</p>

<h2>It's a skill</h2>

<p>Treat interviewing like a skill. It's going to require some practice. It's quite different from programming. Something I've noticed about  over the years is that the inexperienced naive ones tend to think that they know everything whereas experienced programmers know more what they don't know. So as you grow as a programmer, you may even think of yourself as  worse programmer because you grow aware of what you don't know. This is problematic when interviewing because you are essentially selling yourself to the company. If you don't feel the product is good how can you sell it effectively? The next step is to figure out how to sell yourself.</p>

<h2>Practice your pitch</h2>

<p>I firmly believe that you have to have a game plan for the interview. Be familiar with everything you wrote on your resume. Have answers for the most common questions. Be able to relate specific experiences in your career in away that shows your strengths. Have your own pitch ready in the case that the interviewer doesn't have much to say. I've had interviews where the interviewer simply asked open ended questions. It's good to have your pitch ready to hit these questions out of the park.</p>

<h2>Code Examples</h2>

<p>Programming during the interview is silly. It's not an accurate evaluation of a programmer's skills, and I'm not sure what it serves to show the interviewer. I find that an easy way to avoid doing coding during the interview is to have some code examples ready for the interviewer to see. It's important for the interviewer to both see the code and be able to run the app. Personally, I'll build a side project in rails and host it on heroku, which allows the interviewer to review code and easily try out the app.</p>

<p><a href="/blog/importance-of-side-projects">More on side projects here</a>.</p>

<h2>All interviews are practice</h2>

<p>Many programmers get nervous during interviews. I calm my nerves by remembering that all interviews are practice. If you don't get the job it's not a big deal. Simply apply for another job and interview for that one. In the meantime, I get real practice to hone my interview skills. However, before that next interview it's important to try to learn from the interview you just had.</p>

<h2>Evaluate your performance</h2>

<p>What went wrong in the last interview? Where could you have improved? What went well? It's important to critique your performance shortly after your interview. That way you won't miss anything since everything will be fresh in your mind.</p>

<h2>But how do I GET an interview?</h2>

<p>That's the subject of my next post. I'll go over resume and cover letter writing, and some other topics. <a href="/blog/how-to-get-a-programming-interview">Read it here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Importance of Side Projects]]></title>
    <link href="http://rawsyntax.com/blog/importance-of-side-projects/"/>
    <updated>2011-05-29T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/importance-of-side-projects</id>
    <content type="html"><![CDATA[<p>Side projects are important for a few reasons. Programming is a creative process. Side projects allow programming without deadlines or restraints. Side projects allow programming in an exploratory way.</p>

<h2>Explore new technologies</h2>

<p>Every day there are more and more bleeding edge technologies coming out. A side project is a great place to try them out. There's no reason to worry about bugs or performance issues because it's just a side project. You're not depending on the project to pay your bills. It's ok if the website crashes.</p>

<h2>Creating from scratch</h2>

<p>Most jobs I've had so far were mostly maintenance work. Adding new features, fixing bugs, troubleshooting performance problems, refactoring existing code. Though I've built more than a few applications from scratch, it only takes me a couple months to lay the foundation, and then I'm in maintenance mode again.</p>

<p>Side projects require creating from scratch on a regular basis. I love this step because I get to step back and take everything I've learned and put that into creating a new (and improved) project.</p>

<h2>Good enough to launch</h2>

<p>Working on a side project is also an exercise in avoiding analysis paralysis. If you're starting from scratch, the possibilities are endless. A good way to avoid this is to make your short list of must have features, and then launch a beta when you have those features. A so called <a href="http://en.wikipedia.org/wiki/Minimum_viable_product">minimum viable product</a>.</p>

<h2>Staving off burnout</h2>

<p>Work on your passion. Work on something that is fun. If you're a developer who is about to burnout because you don't enjoy what you're working on, try creating your own side project. It will remind you why programming is fun.</p>

<h2>Keeping your skillset current</h2>

<p>Maybe you're working with old technology at your day job. Maybe you're bored with your current skillset and want to learn some new skills. Side  are a great way to keep current with emerging trends in software. Never tried node.js? Great, make a small side project using it. All of a sudden you have something to show off as proof of your newly acquired skills.</p>

<h2>Complete your side project</h2>

<p>One of the problems with side projects is that they can remain incomplete. You may start on a project with all the gusto in the world, but then it's two months later and you can't remember the last time you worked on the side project. Nevertheless it's important to push forward and complete the project. On that note, I'm off to do some work on my side project.</p>
]]></content>
  </entry>
  
</feed>
