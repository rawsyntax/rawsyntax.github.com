<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: code | Raw Syntax]]></title>
  <link href="http://rawsyntax.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://rawsyntax.com/"/>
  <updated>2011-11-29T15:16:26-05:00</updated>
  <id>http://rawsyntax.com/</id>
  <author>
    <name><![CDATA[Eric Himmelreich]]></name>
    <email><![CDATA[eric@rawsyntax.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Use LiveReload with Rails for faster development]]></title>
    <link href="http://rawsyntax.com/blog/use-livereload-with-rails-for-faster-development/"/>
    <updated>2011-08-15T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/use-livereload-with-rails-for-faster-development</id>
    <content type="html"><![CDATA[<p>LiveReload applies CSS/JS changes to Safari or Chrome without reloading the page, and automatically reloads when the html changes. Let that soak in for a minute. In this post I'll go over how to get it installed and working on your Rails projects.</p>

<p>The installation process has two steps. First we install a browser extension that listens for livereload events. Then we use guard to listen for  system events and send information to the browser.</p>

<p>First install the livereload addon for <a href="https://chrome.google.com/webstore/detail/jnihajbhpnppcggbcgedagnkighmdlei">chrome</a> or <a href="https://github.com/downloads/mockko/livereload/LiveReload-1.6.2.safariextz">safari</a>.</p>

<p>In your rails project gemfile add</p>

<pre><code>gem 'rb-fsevent'
gem 'guard-livereload'
</code></pre>

<p>Run</p>

<pre><code>bundle install
</code></pre>

<p>Then run</p>

<pre><code>guard init livereload &amp;&amp; guard
</code></pre>

<p>To setup guard for livereload and start monitoring for file system events. The last step is to activate the browser extension. You will need to click the LiveReload button:</p>

<p><img src="http://media.tumblr.com/tumblr_lpzehwqgO41qfdxjm.png"></p>

<p>Now when you change a file in your view, Safari / Chrome will load the new content automatically.</p>

<h2>Notes on RubyCocoa</h2>

<p>The notes on the <a href="https://github.com/mockko/livereload">livereload repo</a> are a little confusing. Livereload can also work via RubyCocoa (instead of guard- livereload). If you're running ruby 1.9.2 you cannot install RubyCocoa on it. RubyCocoa is not 1.9.x compatible. So I opt to use the browser extension and guard.</p>

<p>More info <a href="http://livereload.com/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Bash: Remove Commands from your History]]></title>
    <link href="http://rawsyntax.com/blog/learn-bash-remove-commands-from-your-history/"/>
    <updated>2011-08-11T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/learn-bash-remove-commands-from-your-history</id>
    <content type="html"><![CDATA[<p>Occasionally I type a password or other sensitive information into a shell
prompt. Using bash history, the command can be removed.</p>

<p><div><script src='https://gist.github.com/1330991.js?file='></script>
<noscript><pre><code># say we start with an empty bash command history
bash-3.2$ history
    1  history


# enter a command that requires a password
bash-3.2$ sudo rm -i some_file
Password:
# accidentally ^C and type your password
# into the prompt and hit enter
bash-3.2$ secret_password
bash: secret_password: command not found


# your password is now there for all to
# see in your bash history
bash-3.2$ history
    1  history
    2  sudo rm -i some_file
    3  secret_password
    4  history


# first option to fix it, delete the numbered entry from
# history and write to your ~/.bash_history file
bash-3.2$ history -d 3
bash-3.2$ history -w


# entry 3 will be removed entirely from your command history
bash-3.2$ history
    1  history
    2  sudo rm -i some_file
    3  history
    4  history -d 3
    5  history -w
    6  history


# the second option is to clear the entire history
# and write the changes to disk
bash-3.2$ history -c
bash-3.2$ history -w


# it's now pretty obvious that your history has been
# scrubbed clean, but at least your password is history!
bash-3.2$ history
    1  history -w
    2  history</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generating Available Domain Names]]></title>
    <link href="http://rawsyntax.com/blog/generating-available-domain-names/"/>
    <updated>2011-04-22T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/generating-available-domain-names</id>
    <content type="html"><![CDATA[<p>It's a ruby script that loads a dictionary of common words, restricts word length, combines two that start with the same letter, and issues a whois query to check if it's available. Feel free to tweak it to your own needs. It also has some sleep calls to avoid flooding the whois server. Let it run for a couple days, see what comes out.</p>

<p>I actually generated <a href="http://rawsyntax.com">rawsyntax.com</a> using this script.</p>

<p><div><script src='https://gist.github.com/1360029.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
require 'rubygems'
require 'whois'

module Domaing
  def self.alliterative?(first_word, second_word)
    first_word[0] == second_word[0]
  end

  def self.generate_names(words)
    first  = words[rand(words.size)].strip.downcase
    second = words[rand(words.size)].strip.downcase

    &quot;#{first}#{second}.com&quot; if alliterative?(first, second)
  end

  def self.generate_domains
    words = []

    File.open(&quot;2of12.txt&quot;, &quot;r&quot;).each_line do |l|
      words &lt;&lt; l if l.length &gt; 4 &amp;&amp;  l.length &lt; 7
    end

    domains = []

    while domains.count &lt; 30000
      domain = generate_names(words)
      domains &lt;&lt; domain if domain
    end

    domains.each  do |d|
      sleep 5
      begin
        if Whois.whois(d).available?
          File.open(&quot;domains.txt&quot;, &quot;a&quot;) do |f|
            f.write &quot;#{d}\n&quot;
          end
        end
      rescue
        sleep 100 # to avoid overloading whois servers
      end
    end
  end
end

Domaing.generate_domains
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 3 Email Validation]]></title>
    <link href="http://rawsyntax.com/blog/rails-3-email-validation/"/>
    <updated>2011-04-21T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/rails-3-email-validation</id>
    <content type="html"><![CDATA[<p>Most email validation I've encountered goes bananas with regards to regexes. The programmer tries to strictly adhere to the spec (<a href="http://www.ietf.org/rfc/rfc0822.txt">rfc 822</a>) in a regex. Not only is this task difficult and error prone, but there are functional email addresses out there that do not conform to the spec. Not to mention the resulting regex often looks like <a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html">this</a>.</p>

<p>When I do email validation I use a simple regex:</p>

<p><div><script src='https://gist.github.com/934791.js?file='></script>
<noscript><pre><code>/^([\w\.%\+\-]+)@([\w\-]+\.)+([\w]{2,})$/i
</code></pre></noscript></div>

Which I took from the <a href="http://github.com/platformatec/devise">Devise</a> codebase. It means:</p>

<ul>
<li>begins with one or more word characters, period, percent, plus, or dashes</li>
<li>then one at symbol</li>
<li>then one or more word characters, dashes, and then a period</li>
<li>ends with 2 or more word characters</li>
<li>case-insensitive</li>
</ul>


<p>This regex ensures a reasonably close to valid email address, without enumerating and worrying about .com vs .co.uk vs .musem and a host of other issues.</p>

<p>At this point, I have the application send an email to the address, and require the user to click a confirmation link. That's good enough, and very simple to implement.</p>

<p><a href="http://rubular.com/r/YTzbCkatJy">Try this regex out on Rubular</a> it's an interactive web based ruby regex engine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL Validation in Rails 3 (and ruby in general)]]></title>
    <link href="http://rawsyntax.com/blog/url-validation-in-rails-3-and-ruby-in-general/"/>
    <updated>2011-01-20T00:00:00-05:00</updated>
    <id>http://rawsyntax.com/blog/url-validation-in-rails-3-and-ruby-in-general</id>
    <content type="html"><![CDATA[<p>I've seen some approaches, most notably <a href="http://www.igvita.com/2006/09/07/validating-url-in-ruby-on-rails/">here on igvita</a>. Though the reference on igvita is quite dated (2006 ??? being more or less the beginning of the epoch in rails-years), I've seen plenty of code using the validate-a-uri-by-regex approach.</p>

<p>It doesn't work and pretty much always ends up excluding valid urls. This is why I prefer to use the parsing approach. If the url can be parsed, and the scheme seems reasonably valid, good enough.</p>

<h2>An Interesting URL Problem</h2>

<p>Recently I ran into a situation where I needed to be able to validate and handle unicode / internationalized links. One such link would be <a href="http://%D0%BA%D1%86.%D1%80%D1%84">the russian tld registrar кц.рф</a>. The typical approach of parsing with URI fails below</p>

<p><div><script src='https://gist.github.com/789195.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'uri'

URI.parse(&quot;кц.рф&quot;)

# fails with the following error
#
#/Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:156:in `split': bad URI(is not
# URI?): кц.рф (URI::InvalidURIError)
#	from /Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:174:in `parse'
#	from /Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:628:in `parse'
#	from ./uri-parse.rb:6:in `&lt;main&gt;'
</code></pre></noscript></div>
</p>

<h2>The Solution</h2>

<p>At this point, I happened to remember there is another library for parsing URIs. It's called <a href="https://github.com/sporkmonger/addressable">Addressable::URI</a>. Its aim is to be a full replacement of the ruby standard library's URI module.</p>

<p>More importantly, it successfully parses unicode urls.
<div><script src='https://gist.github.com/789235.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'addressable/uri'

Addressable::URI.parse(&quot;кц.рф&quot;)

# no problem at all</code></pre></noscript></div>
</p>

<p>Here's how I do URL validation in rails 3, using ActiveModel and Addressable::URI.
<div><script src='https://gist.github.com/789162.js?file='></script>
<noscript><pre><code>class Example
  include ActiveModel::Validations

  ##
  # Validates a URL
  #
  # If the URI library can parse the value, and the scheme is valid
  # then we assume the url is valid
  #
  class UrlValidator &lt; ActiveModel::EachValidator
    def validate_each(record, attribute, value)
      begin
        uri = Addressable::URI.parse(value)

        if ![&quot;http&quot;,&quot;https&quot;,&quot;ftp&quot;].include?(uri.scheme)
          raise Addressable::URI::InvalidURIError
        end
      rescue Addressable::URI::InvalidURIError
        record.errors[attribute] &lt;&lt; &quot;Invalid URL&quot;
      end
    end
  end

  validates :field, :url =&gt; true
end</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
