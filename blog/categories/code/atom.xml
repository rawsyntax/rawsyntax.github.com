<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: code | Raw Syntax]]></title>
  <link href="http://rawsyntax.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://rawsyntax.com/"/>
  <updated>2011-11-11T23:48:53-05:00</updated>
  <id>http://rawsyntax.com/</id>
  <author>
    <name><![CDATA[Eric Himmelreich]]></name>
    <email><![CDATA[eric@rawsyntax.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learn Bash: Remove Commands from your History]]></title>
    <link href="http://rawsyntax.com/blog/learn-bash-remove-commands-from-your-history/"/>
    <updated>2011-08-11T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/learn-bash-remove-commands-from-your-history</id>
    <content type="html"><![CDATA[<p>Occasionally I type a password or other sensitive information into a shell
prompt. Using bash history, the command can be removed.</p>

<p><div><script src='https://gist.github.com/1330991.js?file='></script>
<noscript><pre><code># say we start with an empty bash command history
bash-3.2$ history
    1  history


# enter a command that requires a password
bash-3.2$ sudo rm -i some_file
Password:
# accidentally ^C and type your password
# into the prompt and hit enter
bash-3.2$ secret_password
bash: secret_password: command not found


# your password is now there for all to
# see in your bash history
bash-3.2$ history
    1  history
    2  sudo rm -i some_file
    3  secret_password
    4  history


# first option to fix it, delete the numbered entry from
# history and write to your ~/.bash_history file
bash-3.2$ history -d 3
bash-3.2$ history -w


# entry 3 will be removed entirely from your command history
bash-3.2$ history
    1  history
    2  sudo rm -i some_file
    3  history
    4  history -d 3
    5  history -w
    6  history


# the second option is to clear the entire history
# and write the changes to disk
bash-3.2$ history -c
bash-3.2$ history -w


# it's now pretty obvious that your history has been
# scrubbed clean, but at least your password is history!
bash-3.2$ history
    1  history -w
    2  history</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generating Available Domain Names]]></title>
    <link href="http://rawsyntax.com/blog/generating-available-domain-names/"/>
    <updated>2011-04-22T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/generating-available-domain-names</id>
    <content type="html"><![CDATA[<p>It's a ruby script that loads a dictionary of common words, restricts word length, combines two that start with the same letter, and issues a whois query to check if it's available. Feel free to tweak it to your own needs. It also has some sleep calls to avoid flooding the whois server. Let it run for a couple days, see what comes out.</p>

<p>I actually generated <a href="http://rawsyntax.com">rawsyntax.com</a> using this script.</p>

<p><div><script src='https://gist.github.com/1360029.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
require 'rubygems'
require 'whois'

module Domaing
  def self.alliterative?(first_word, second_word)
    first_word[0] == second_word[0]
  end

  def self.generate_names(words)
    first  = words[rand(words.size)].strip.downcase
    second = words[rand(words.size)].strip.downcase

    &quot;#{first}#{second}.com&quot; if alliterative?(first, second)
  end

  def self.generate_domains
    words = []

    File.open(&quot;2of12.txt&quot;, &quot;r&quot;).each_line do |l|
      words &lt;&lt; l if l.length &gt; 4 &amp;&amp;  l.length &lt; 7
    end

    domains = []

    while domains.count &lt; 30000
      domain = generate_names(words)
      domains &lt;&lt; domain if domain
    end

    domains.each  do |d|
      sleep 5
      begin
        if Whois.whois(d).available?
          File.open(&quot;domains.txt&quot;, &quot;a&quot;) do |f|
            f.write &quot;#{d}\n&quot;
          end
        end
      rescue
        sleep 100 # to avoid overloading whois servers
      end
    end
  end
end

Domaing.generate_domains
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 3 Email Validation]]></title>
    <link href="http://rawsyntax.com/blog/rails-3-email-validation/"/>
    <updated>2011-04-21T00:00:00-04:00</updated>
    <id>http://rawsyntax.com/blog/rails-3-email-validation</id>
    <content type="html"><![CDATA[<p>Most email validation I've encountered goes bananas with regards to regexes. The programmer tries to strictly adhere to the spec (<a href="http://www.ietf.org/rfc/rfc0822.txt">rfc 822</a>) in a regex. Not only is this task difficult and error prone, but there are functional email addresses out there that do not conform to the spec. Not to mention the resulting regex often looks like <a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html">this</a>.</p>

<p>When I do email validation I use a simple regex:</p>

<p><div><script src='https://gist.github.com/934791.js?file='></script>
<noscript><pre><code>/^([\w\.%\+\-]+)@([\w\-]+\.)+([\w]{2,})$/i
</code></pre></noscript></div>

Which I took from the <a href="http://github.com/platformatec/devise">Devise</a> codebase. It means:</p>

<ul>
<li>begins with one or more word characters, period, percent, plus, or dashes</li>
<li>then one at symbol</li>
<li>then one or more word characters, dashes, and then a period</li>
<li>ends with 2 or more word characters</li>
<li>case-insensitive</li>
</ul>


<p>This regex ensures a reasonably close to valid email address, without enumerating and worrying about .com vs .co.uk vs .musem and a host of other issues.</p>

<p>At this point, I have the application send an email to the address, and require the user to click a confirmation link. That's good enough, and very simple to implement.</p>

<p><a href="http://rubular.com/r/YTzbCkatJy">Try this regex out on Rubular</a> it's an interactive web based ruby regex engine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL Validation in Rails 3 (and ruby in general)]]></title>
    <link href="http://rawsyntax.com/blog/url-validation-in-rails-3-and-ruby-in-general/"/>
    <updated>2011-01-20T00:00:00-05:00</updated>
    <id>http://rawsyntax.com/blog/url-validation-in-rails-3-and-ruby-in-general</id>
    <content type="html"><![CDATA[<p>I've seen some approaches, most notably <a href="http://www.igvita.com/2006/09/07/validating-url-in-ruby-on-rails/">here on igvita</a>. Though the reference on igvita is quite dated (2006 ??? being more or less the beginning of the epoch in rails-years), I've seen plenty of code using the validate-a-uri-by-regex approach.</p>

<p>It doesn't work and pretty much always ends up excluding valid urls. This is why I prefer to use the parsing approach. If the url can be parsed, and the scheme seems reasonably valid, good enough.</p>

<h2>An Interesting URL Problem</h2>

<p>Recently I ran into a situation where I needed to be able to validate and handle unicode / internationalized links. One such link would be <a href="http://%D0%BA%D1%86.%D1%80%D1%84">the russian tld registrar кц.рф</a>. The typical approach of parsing with URI fails below</p>

<p><div><script src='https://gist.github.com/789195.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'uri'

URI.parse(&quot;кц.рф&quot;)

# fails with the following error
#
#/Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:156:in `split': bad URI(is not
# URI?): кц.рф (URI::InvalidURIError)
#	from /Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:174:in `parse'
#	from /Users/eric/.rvm/rubies/ruby-1.9.2-p136/lib/ruby/1.9.1/uri/common.rb:628:in `parse'
#	from ./uri-parse.rb:6:in `&lt;main&gt;'
</code></pre></noscript></div>
</p>

<h2>The Solution</h2>

<p>At this point, I happened to remember there is another library for parsing URIs. It's called <a href="https://github.com/sporkmonger/addressable">Addressable::URI</a>. Its aim is to be a full replacement of the ruby standard library's URI module.</p>

<p>More importantly, it successfully parses unicode urls.
<div><script src='https://gist.github.com/789235.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'addressable/uri'

Addressable::URI.parse(&quot;кц.рф&quot;)

# no problem at all</code></pre></noscript></div>
</p>

<p>Here's how I do URL validation in rails 3, using ActiveModel and Addressable::URI.
<div><script src='https://gist.github.com/789162.js?file='></script>
<noscript><pre><code>class Example
  include ActiveModel::Validations

  ##
  # Validates a URL
  #
  # If the URI library can parse the value, and the scheme is valid
  # then we assume the url is valid
  #
  class UrlValidator &lt; ActiveModel::EachValidator
    def validate_each(record, attribute, value)
      begin
        uri = Addressable::URI.parse(value)

        if ![&quot;http&quot;,&quot;https&quot;,&quot;ftp&quot;].include?(uri.scheme)
          raise Addressable::URI::InvalidURIError
        end
      rescue Addressable::URI::InvalidURIError
        record.errors[attribute] &lt;&lt; &quot;Invalid URL&quot;
      end
    end
  end

  validates :field, :url =&gt; true
end</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Freelancing on oDesk]]></title>
    <link href="http://rawsyntax.com/blog/freelancing-on-odesk/"/>
    <updated>2010-12-06T00:00:00-05:00</updated>
    <id>http://rawsyntax.com/blog/freelancing-on-odesk</id>
    <content type="html"><![CDATA[<p>Since the start of my career as a professional programmer, I've been interested in doing contract work online. Over the years I've half-heartedly tried to get jobs on sites like <a href="http://www.elance.com/">elance</a>, <a href="http://rentacoder.com">rentacoder</a>, and <a href="http://www.guru.com">guru</a>. I never had any success. All I found was employers / providers offering $200 fixed-bid contracts for building <a href="http://facebook.com">facebook</a> / <a href="http://ebay.com">ebay</a> clones, and workers willing to work for way less than I would or even could. In November 2010, after reading enough posts on <a href="http://news.ycombinator.com">hacker news</a> I decided to give <a href="http://odesk.com">oDesk</a> an honest try.</p>

<h2>Trying oDesk for a Full Month</h2>

<p>I committed myself to trying get jobs on <a href="http://www.odesk.com">oDesk</a> for a full month. I found the usual unrealistic jobs (demanding everything for nothing). I focused narrowly on <a href="http://www.ruby-lang.org/">ruby</a> and <a href="http://rubyonrails.org">rails</a> since that's been the focus of my skill-set the past few years.</p>

<h2>Fixed-bid Projects</h2>

<p>After a few days of applying to 2-3 jobs per day, I finally got an acceptance. It should be noted that for each of these jobs I wrote a detailed and specially tailored cover letter selling myself to the employer. I believe this is crucial. Writing cover letters is worth getting good at.</p>

<p>The job was to modify the
<a href="https://github.com/Shopify/active_merchant">ActiveMerchant</a> gem to add support for a new payment gateway. I wrote <a href="https://jadedpixel.lighthouseapp.com/projects/11599/tickets/199-patch-added-merchant-warrior-gateway">this patch</a> for <a href="http://merchantwarrior.com">MerchantWarrior</a> in about 8 hours start to finish. It was a fixed bid project and the employer paid me promptly.</p>

<p>I got this project after only a few days, and I was ready for more. The next job I did was basically rails troubleshooting for another developer over skype. It consisted of a few small bugs, each of which were small fixed-bid projects. The guy would skype me, name his price, then I'd fix his bugs in his rails applications, explain why, and he'd pay me. It wasn't much money, but these were small bugs, and it boosted my feedback rating on <a href="http://odesk.com">oDesk</a>.</p>

<p>On to the next job! November was turning out to be a good month for trying out online contracting. At this point I had only done fixed-bid contracts. I wanted something bigger. I wanted hourly work on <a href="http://odesk.com">oDesk</a>. Hourly work is special because <a href="http://odesk.com">oDesk</a> guarantees payment for hours worked. They have an application that you run on your desktop that tracks hours worked, takes screenshots, and lists average keystrokes and mouse actions.</p>

<h2>Hourly Work</h2>

<p>The first hourly project I got was a small ruby integration with <a href="http://ifbyphone.com">ifbyphone</a>. I had used ifbyphone before, so I wrote a cover letter selling myself hard (knowing ruby, having used ifbyphone before). I was also asked to justify my hourly rate, since it was higher than the typical hourly rate on <a href="http://odesk.com">oDesk</a>. This was easy enough.</p>

<p>As soon as I delivered the code for this project, the employer offered me some work building a ruby gem. It's basically a simplistic template-based email parser. It's rather fragile, but given the employer's time constraints, it does what he wants. I ended up codifying the employer's requirements into <a href="http://rspec.info">rspec</a> tests.</p>

<p>Once I finished that project, the same employer offered me some more hourly work in the form of a rails project. It's a microsite for people who play farmville. For the record, I do not play farmville. There are plenty of other more interesting video games to play. The site is basically a lookup table for some farmville data. It's sortable and can be filtered to the user's specifications. I'm not yet finished with this project.</p>
]]></content>
  </entry>
  
</feed>
